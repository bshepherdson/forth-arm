<HTML>
<HEAD><TITLE>The Z-Machine Standards Document</TITLE>
</HEAD>

<BODY BGCOLOR="#EEEEEE"><H1 align=center><IMG height=86 width=82
SRC="icon12.gif" ALT="Z"></H1>
<BR><H3 align=center><I>12. The object table</I></H3>
<HR>
12.1 <A HREF="#one">Storage</A> / 
12.2 <A HREF="#two">Property defaults table</A> / 
12.3 <A HREF="#three">Object tree</A> /
12.4 <A HREF="#four">Property tables</A> / 
12.5 <A HREF="#five">Well-foundedness of the tree</A>
<HR><A NAME="one">
<BR><B>12.1</B><P>
The object table is held in dynamic memory and its byte address
is stored in the word at <B>$0a</B> in the header.  (Recall that objects
have flags attached called attributes, numbered from 0 upward, and
variables attached called properties, numbered from 1 upward.  An
object need not provide every property.)
<P><A NAME="two">
<BR><B>12.2</B><P>
The table begins with a block known as the property defaults table.
This contains 31 words in Versions 1 to 3 and 63 in Versions 4 and later.
When the game attempts to read the value of property n for an object
which does not provide property n, the n-th entry in this table
is the resulting value.
<P><A NAME="three">
<BR><B>12.3</B><P>
Next is the object tree.  Objects are numbered consecutively from
1 upward, with object number 0 being used to mean "nothing" (though
there is formally no such object).  The table consists of a list of
entries, one for each object.
<P>
<BR><B>12.3.1</B><P>
In Versions 1 to 3, there are at most 255 objects, each having
a 9-byte entry as follows:
<PRE>
   the 32 attribute flags     parent     sibling     child   properties
   ---32 bits in 4 bytes---   ---3 bytes------------------  ---2 bytes--
</PRE>
<B>parent</B>, <B>sibling</B> and <B>child</B> must all hold valid object numbers.
The <B>properties</B> pointer is the byte address of the list of
properties attached to the object.  Attributes 0 to 31 are flags
(at any given time, they are either on (1) or off (0)) and are stored topmost
bit first: e.g., attribute 0 is stored in bit 7 of the first byte,
attribute 31 is stored in bit 0 of the fourth.
<P>
<BR><B>12.3.2</B><P>
In Version 4 and later, there are at most 65535 objects, each
having a 14-byte entry as follows:
<PRE>
    the 48 attribute flags     parent    sibling   child     properties
   ---48 bits in 6 bytes---   ---3 words, i.e. 6 bytes----  ---2 bytes--
</PRE>
<P><A NAME="four">
<BR><B>12.4</B><P>
Each object has its own property table.  Each of these can be
anywhere in dynamic memory (indeed, a game can legally change an object's
properties table address in play, provided the new address points to
another valid properties table).
The header of a property table is as follows:
<PRE>
   text-length     text of short name of object
  -----byte----   --some even number of bytes---
</PRE>
where the <B>text-length</B>
is the number of 2-byte words making up the text,
which is stored in the usual format.  (This means that an object's short
name is limited to 765 Z-characters.)  After the header, the properties
are listed in descending numerical order.  (This order is essential and
is not a matter of convention.)<P>
<BR><B>12.4.1</B><P>
In Versions 1 to 3, each property is stored as a block
<PRE>
   size byte     the actual property data
                ---between 1 and 8 bytes--
</PRE>
where the <B>size byte</B> is arranged as 32 times the number of data bytes
minus one, plus the property number. A property list is terminated by
a size byte of 0.  (It is otherwise illegal for a size byte to be a
multiple of 32.)
<P>
<BR><B>12.4.2</B><P>
In Versions 4 and later, a property block instead has the form
<PRE>
   size and number       the actual property data
  --1 or 2 bytes---     --between 1 and 64 bytes--
</PRE>
The property number occupies the bottom 6 bits of the first size byte.
<P>
<BR><B>12.4.2.1</B><P>
If the top bit (bit 7) of the first size byte is set, then there are
two size-and-number bytes as follows.  In the first byte, bits 0 to
5 contain the property number; bit 6 is undetermined (it is clear in
all Infocom or Inform story files); bit 7 is set.  In the second byte,
bits 0 to 5 contain the property data length, counting in bytes;
bit 6 is undetermined (it is set in Infocom story files, but clear
in Inform ones); bit 7 is always set.
<P>
<BR><B>12.4.2.1.1</B><P>
<B>***</B> A value of 0 as property data length (in the second
byte) should be interpreted as a length of 64.  (Inform can compile
such properties.)
<P>
<BR><B>12.4.2.2</B><P>
If the top bit (bit 7) of the first size byte is clear, then there is
only one size-and-number byte.  Bits 0 to 5 contain the property number;
bit 6 is either clear to indicate a property data length of 1, or
set to indicate a length of 2; bit 7 is clear.
<P><A NAME="five">
<BR><B>12.5</B><P>
It is the game's responsibility to keep the object tree
well-founded: the interpreter is not required to check.
"Well-founded" means the following:
<P><B>(a)</B> An object with a sibling also has a parent.
<P><B>(b)</B> An object is the parent of exactly those objects
in the sibling list of its child.
<P><B>(c)</B> Each object can be given a level n, such that
parentless objects have level 0 and all children of a level
n object have level n+1.
<P>
<HR><H4><I>Remarks</I></H4><BR>
The largest valid object number is not directly stored anywhere
in the Z-machine.  Utility programs like <B>Infodump</B> deduce this
number by assuming that, initially, the object entries end where
the first property table begins.
<P>
Infocom's 'Sherlock' contains a bug making it try to set and
clear attribute 48.
<P>
The reason why the second property size byte needs to have top bit
set is that the size field must be parsable either forwards or
backwards -- the Z-machine needs to be able to reconstruct the
length of a property given only the address of the first byte
of its data.  (There are very many (e.g. 2000) property entries
in a story file, so optimising size into one byte most of the
time is worthwhile.)
<P>
Bit 6 in the second byte is presently wasted, which is a pity as
it could be used to allow up to 128 bytes of property data.  But such
a change would cause Infocom's story files to fail (since they
set this bit, unlike Inform story files).
<P>
Inform can only construct well-founded object trees as the initial game
state, but it is easy to compile sequences of code like "move red box to
blue box" followed by "move blue box to red box" which leave the object
tree in an ill-founded state.  (The Inform library protects the standard
object-movement verbs against this.)
<P>
<HR>
<P>
<A HREF="index.html">Contents</A> / <A HREF="preface.html">Preface</A> /
<A HREF="overview.html">Overview</A>
<P>Section
<A HREF="sect01.html">1</A> / <A HREF="sect02.html">2</A> /
<A HREF="sect03.html">3</A> / <A HREF="sect04.html">4</A> /
<A HREF="sect05.html">5</A> / <A HREF="sect06.html">6</A> /
<A HREF="sect07.html">7</A> / <A HREF="sect08.html">8</A> /
<A HREF="sect09.html">9</A> / <A HREF="sect10.html">10</A> /
<A HREF="sect11.html">11</A> / <A HREF="sect12.html">12</A> /
<A HREF="sect13.html">13</A> / <A HREF="sect14.html">14</A> /
<A HREF="sect15.html">15</A> / <A HREF="sect16.html">16</A>
<P>Appendix
<A HREF="appa.html">A</A> / <A HREF="appb.html">B</A> /
<A HREF="appc.html">C</A> / <A HREF="appd.html">D</A> /
<A HREF="appe.html">E</A> / <A HREF="appf.html">F</A>
</P>
<HR>

</BODY></HTML>
