<HTML>
<HEAD><TITLE>The Z-Machine Standards Document</TITLE>
</HEAD>

<BODY BGCOLOR="#EEEEEE"><H1 align=center><IMG height=86 width=82
SRC="icon02.gif" ALT="Z"></H1>
<BR><H3 align=center><I>2. Numbers and arithmetic</I></H3>

<HR>
2.1 <A HREF="#one">Numbers</A> /
2.2 <A HREF="#two">Signed operations</A> /
2.3 <A HREF="#three">Arithmetic errors</A> /
2.4 <A HREF="#four">Random number generator</A>
<HR><A NAME="one">
<BR><B>2.1</B><P> In the Z-machine, numbers are usually stored in 2 bytes
(in the form most-significant-byte first, then least-significant)
and hold any value in the range <B>$0000</B> to <B>$ffff</B> (0 to 65535
decimal).
<P><A NAME="two">
<BR><B>2.2</B><P> These values are sometimes regarded as signed, in the range
$-32768$ to $32767$.  In effect $-n$ is stored as $65536-n$
and so the top bit is the sign bit.
<P>
<BR><B>2.2.1</B><P> The operations of numerical comparison, multiplication,
addition, subtraction, division, remainder-after-division and
printing of numbers are signed; bitwise operations are unsigned.
(In particular, since comparison is signed, it is unsafe to compare
two addresses using simply <B>jl</B> and <B>jg</B>.)
<P><A NAME="three">
<BR><B>2.3</B><P> Arithmetic errors:
<P>
<BR><B>2.3.1</B><P> It is illegal to divide by 0 (or to ask for remainder after
division by 0) and an interpreter should halt with an error message
if this occurs.
<P>
<BR><B>2.3.2</B><P> Formally it has never been specified what the result of an
out-of-range calculation should be.  The author suggests that the
result should be reduced modulo <B>$10000</B>.
<P><A NAME="four">
<BR><B>2.4</B><P> The Z-machine needs a random number generator which at any time
has one of two states, "random" and "predictable".  When the game
starts or restarts the state becomes "random".  Ideally the generator
should not produce identical sequences after each restart.
<P>
<BR><B>2.4.1</B><P> When "random", it must be capable of generating a uniformly
random integer in the range 1 <= x <= n, for any value
1 <= n <= 32767.  Any method can be used for this (for instance,
using the host computer's clock time in milliseconds).  The uniformity
of randomness should be optimised for low values of n (say, up to
100 or so) and it is especially important to avoid regular patterns
appearing in remainders after division (most crudely, being alternately
odd and even).
<P>
<BR><B>2.4.2</B><P> The generator is switched into "predictable" state with a
seed value.  On any two occasions when the same seed is sown, identical
sequences of values must result (for an indefinite period) until
the generator is switched back into "random" mode.  The generator
should cope well with very low seed values, such as 10, and should not
depend on the seed containing many non-zero bits.
<P>
<BR><B>2.4.3</B><P> The interpreter is permitted to switch between these states
on request of the player.  (This is useful for testing purposes.)
<P>
<HR><H4><I>Remarks</I></H4><BR>
It is dangerous to rely on the ANSI C random number routines, as some
implementations of these are very poor.  This has made some games (in
particular, 'Balances') unwinnable on some Unix ports of <B>Zip</B>.
<P>
The author suggests the following algorithm:
<P><B>1.</B> In "random" mode, the generator uses the host computer's
clock to obtain a random sequence of bits.
<P><B>2.</B> In "predictable" mode, the generator should store the
seed value <I>S</I>.  If <I>S</I> < 1000 it should then internally generate
<P>1, 2, 3, ..., <I>S</I>, 1, 2, 3, ..., <I>S</I>, 1, ...
<P>
so that <B>random n</B> produces the next entry in this sequence modulo n.
If <I>S</I> >= 1000 then <I>S</I> is used as a seed in a standard seeded
random-number generator.
<P>
(The rising sequence is useful for testing, since it will
produce all possible values in sequence.  On the other hand, a seeded
but fairly random generator is useful for testing entire scripts.)
<P>
Note that version 0.2 of this standard mistakenly asserted that division
and remainder are unsigned, a myth deriving from a bug in <B>Zip</B>.  Infocom's
interpreters do sign division (this is relied on when calculating
pizza cooking times for the microwave oven in 'The Lurking Horror'). Here
are some correct Z-machine calculations:
<PRE>
   -11 / 2 = -5       -11 / -2 = 5        11 / -2 = -5
   -13 % 5 = -3        13 % -5 = 3       -13 % -5 = -3
</PRE>
<HR>
<P>
<A HREF="index.html">Contents</A> / <A HREF="preface.html">Preface</A> /
<A HREF="overview.html">Overview</A>
<P>Section
<A HREF="sect01.html">1</A> / <A HREF="sect02.html">2</A> /
<A HREF="sect03.html">3</A> / <A HREF="sect04.html">4</A> /
<A HREF="sect05.html">5</A> / <A HREF="sect06.html">6</A> /
<A HREF="sect07.html">7</A> / <A HREF="sect08.html">8</A> /
<A HREF="sect09.html">9</A> / <A HREF="sect10.html">10</A> /
<A HREF="sect11.html">11</A> / <A HREF="sect12.html">12</A> /
<A HREF="sect13.html">13</A> / <A HREF="sect14.html">14</A> /
<A HREF="sect15.html">15</A> / <A HREF="sect16.html">16</A>
<P>Appendix
<A HREF="appa.html">A</A> / <A HREF="appb.html">B</A> /
<A HREF="appc.html">C</A> / <A HREF="appd.html">D</A> /
<A HREF="appe.html">E</A> / <A HREF="appf.html">F</A>
</P>
<HR>

</BODY></HTML>
