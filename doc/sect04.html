<HTML>
<HEAD><TITLE>The Z-Machine Standards Document</TITLE>
</HEAD>

<BODY BGCOLOR="#EEEEEE"><H1 align=center><IMG height=86 width=82
SRC="icon04.gif" ALT="Z"></H1>
<BR><H3 align=center><I>4. How instructions are encoded</I></H3>
<P>
<BLOCKQUOTE>
We do but teach bloody instructions
<P>Which, being taught, return to plague th' inventor
<P>Shakespeare, <B>Macbeth</B>
</BLOCKQUOTE>
<HR>
4.1 <A HREF="#one">Instructions</A> / 
4.2 <A HREF="#two">Operand types</A> / 
4.3 <A HREF="#three">Form and operand count</A> /
4.4 <A HREF="#four">Specifying operand types</A> / 
4.5 <A HREF="#five">Operands</A> / 
4.6 <A HREF="#six">Stores</A> / 
4.7 <A HREF="#seven">Branches</A> / 
4.8 <A HREF="#eight">Text opcodes</A>
<HR><A NAME="one">
<BR><B>4.1</B><P> A single Z-machine instruction consists of the following
sections (and in the order shown):
<PRE>
  Opcode               1 or 2 bytes
  (Types of operands)  1 or 2 bytes: 4 or 8 2-bit fields
  Operands             Between 0 and 8 of these: each 1 or 2 bytes
  (Store variable)     1 byte
  (Branch offset)      1 or 2 bytes
  (Text to print)      An encoded string (of unlimited length)
</PRE>
Bracketed sections are not present in all opcodes.  (A few opcodes
take both "store" and "branch".)
<P><A NAME="two">
<BR><B>4.2</B><P> There are four 'types' of operand.  These are often specified
by a number stored in 2 binary digits:
<PRE>
  $$00    Large constant (0 to 65535)    2 bytes
  $$01    Small constant (0 to 255)      1 byte
  $$10    Variable                       1 byte
  $$11    Omitted altogether             0 bytes
</PRE>
<P>
<BR><B>4.2.1</B><P> Large constants, like all 2-byte words of data in the Z-machine,
are stored with most significant byte first (e.g. <B>$2478</B> is stored as
<B>$24</B> followed by <B>$78</B>).  A 'large constant' may in fact be a small
number.
<P>
<BR><B>4.2.2</B><P> Variable number <B>$00</B> refers to the top of the stack,
<B>$01</B> to <B>$0f</B> mean the local variables of the current routine
and <B>$10</B> to <B>$ff</B> mean the global variables.  It is illegal to
refer to local variables which do not exist for the current routine
(there may even be none).
<P>
<BR><B>4.2.3</B><P> The type 'Variable' really means "variable by value".  Some
instructions take as an operand a "variable by reference": for instance,
<B>inc</B> has one operand, the reference number of a variable to increment.
This operand usually has type 'Small constant' (and Inform automatically
assembles a line like <B>@inc turns</B> by writing the operand <B>turns</B> as
a small constant with value the reference number of the variable <B>turns</B>).
<P><A NAME="three">
<BR><B>4.3</B><P> Each instruction has a form (long, short, extended or variable)
and an operand count (0OP, 1OP, 2OP or VAR).
If the top two bits of the opcode are <B>$$11</B> the form is variable;
if <B>$$10</B>, the form is short.  If the opcode is 190 (<B>$BE</B> in hexadecimal)
and the version is 5 or later, the form is "extended".  Otherwise, the
form is "long".
<P>
<BR><B>4.3.1</B><P> In short form, bits 4 and 5 of the opcode byte give an operand
type as above.  If this is <B>$11</B> then the operand count is
0OP; otherwise, 1OP.  In either case the opcode number is
given in the bottom 4 bits.
<P>
<BR><B>4.3.2</B><P> In long form the operand count is always 2OP.  The opcode number
is given in the bottom 5 bits.
<P>
<BR><B>4.3.3</B><P> In variable form, if bit 5 is 0 then the count is 2OP;
if it is 1, then the count is VAR.  The opcode number is given
in the bottom 5 bits.
<P>
<BR><B>4.3.4</B><P> In extended form, the operand count is VAR.  The opcode number
is given in a second opcode byte.
<P><A NAME="four">
<BR><B>4.4</B><P> Next, the types of the operands are specified.
<P>
<BR><B>4.4.1</B><P> In short form, bits 4 and 5 of the opcode give the type.
<P>
<BR><B>4.4.2</B><P> In long form, bit 6 of the opcode gives the type of
the first operand, bit 5 of the second.  A value of 0 means a small
constant and 1 means a variable.  (If a 2OP instruction needs a
large constant as operand, then it should be assembled in variable
rather than long form.)
<P>
<BR><B>4.4.3</B><P> In variable or extended forms, a byte of 4 operand types is
given next.  This contains 4 2-bit fields: bits 6 and 7 are the first
field, bits 0 and 1 the fourth.  The values are operand types as above.
Once one type has been given as 'omitted', all subsequent ones must
be.  Example: <B>$$00101111</B> means large constant followed by variable
(and no third or fourth opcode).
<P>
<BR><B>4.4.3.1</B><P> In the special case of the "double variable" VAR opcodes
<B>call_vs2</B> and <B>call_vn2</B> (opcode numbers 12 and 26), a second byte
of types is given, containing the types for the next four operands.
<P><A NAME="five">
<BR><B>4.5</B><P> The operands are given next.  Operand counts of 0OP, 1OP or 2OP
require 0, 1 or 2 operands to be given, respectively.  If the count is VAR,
there must be as many operands as there were types other than 'omitted'.
<P>
<BR><B>4.5.1</B><P> Note that only <B>call_vs2</B> and <B>call_vn2</B> can have more than 4
operands, and no instruction can have more than 8.
<P><A NAME="six">
<BR><B>4.6</B><P> "Store" instructions return a value: e.g., <B>mul</B> multiplies
its two operands together.  Such instructions must be followed by a
single byte giving the variable number of where to put the result.
<P><A NAME="seven">
<BR><B>4.7</B><P> Instructions which test a condition are called "branch"
instructions.  The branch information is stored in one or two bytes,
indicating what to do with the result of the test.  If bit 7 of
the first byte is 0, a branch occurs when the condition was false;
if 1, then branch is on true.  If bit 6 is set, then the branch
occupies 1 byte only, and the "offset" is in the range 0 to 63,
given in the bottom 6 bits.  If bit 6 is clear, then the offset is
a signed 14-bit number given in bits 0 to 5 of the first byte
followed by all 8 of the second.
<P>
<BR><B>4.7.1</B><P> An offset of 0 means "return false from the current
routine", and 1 means "return true from the current routine".
<P>
<BR><B>4.7.2</B><P> Otherwise, a branch moves execution to the instruction at
address
<PRE>
  Address after branch data + Offset - 2.
</PRE>
<P><A NAME="eight">
<BR><B>4.8</B><P> Two opcodes, <B>print</B> and <B>print_ret</B>, are followed by a text
string.  This is stored according to the usual rules: in particular
execution continues after the last 2-byte word of text (the one with
top bit set).
<P>
<HR><H4><I>Remarks</I></H4><BR>
Some opcodes have type VAR only because the available codes for
the other types had run out; <B>print_char</B>, for instance.  Others, especially
<B>call</B>, need the flexibility to have between 1 and 4 operands.
<P>
The Inform assembler can assemble branches in either form, though
the programmer should always use long form unless there's a good
reason.  Inform automatically optimises branch statements so as to
force as many of them as possible into short form.  (This optimisation
will happen to branches written by hand in assembler as well as
to branches compiled by Inform.)
<P>
The disassembler <B>Txd</B> numbers locals from 0 to 14 and globals from
0 to 239 in its output (corresponding to variable numbers 1 to 15, and
16 to 255, respectively).
<P>
The branch formula is sensible because in the natural implementation,
the program counter is at the address after the branch data when the branch
takes place: thus it can be regarded as
<PRE>
  PC = PC + Offset - 2.
</PRE>
If the rule were simply "add the offset" then, since the offset couldn't
be 0 or 1 (because of the return-false and return-true values), we would
never be able to skip past a 1-byte instruction (say, a 0OP like <B>quit</B>),
or specify the branch "don't branch at all" (sometimes useful to ignore
the result of the test altogether).  Subtracting 2 means that the only
effects we can't achieve are
<PRE>
  PC = PC - 1     and     PC = PC - 2
</PRE>
and we would never want these anyway, since they would put the program
counter somewhere back inside the same instruction, with horrid
consequences.
<P>
<HR><H4><I>On disassembly</I></H4><BR>

Briefly, the first byte of an instruction can be decoded
using the following table:
<PRE>
  $00 -- $1f  long      2OP     small constant, small constant
  $20 -- $3f  long      2OP     small constant, variable
  $40 -- $5f  long      2OP     variable, small constant
  $60 -- $7f  long      2OP     variable, variable
  $80 -- $8f  short     1OP     large constant
  $90 -- $9f  short     1OP     small constant
  $a0 -- $af  short     1OP     variable
  $b0 -- $bf  short     0OP
  except $be  extended opcode given in next byte
  $c0 -- $df  variable  2OP     (operand types in next byte)
  $e0 -- $ff  variable  VAR     (operand types in next byte(s))
</PRE>
Here is an example disassembly:
<PRE>
  @inc_chk c 0 label;    05 02 00 d4
      long form; count 2OP; opcode number 5; operands:
          02     small constant (referring to variable c)
          00     small constant 0
      branch if true: 1-byte offset, 20 (since label is
      18 bytes forward from here).
  @print "Hello.^";      b2 11 aa 46 34 16 45 9c a5 
      short form; count 0OP.
      literal string, Z-chars: 4 13 10  17 17 20  5 18 5  7 5 5.
  @mul 1000 c -> sp;     d6 2f 03 e8 02 00
      variable form; count 2OP; opcode number 22; operands:
          03 e8  long constant (1000 decimal)
          02     variable c
      store result to stack pointer (var number 00).
  @call_1n Message;      8f 01 56
      short form; count 1OP; opcode number 15; operand:
          01 56  long constant (packed address of routine)
  .label;
</PRE>
<P>
<HR>
<P>
<A HREF="index.html">Contents</A> / <A HREF="preface.html">Preface</A> /
<A HREF="overview.html">Overview</A>
<P>Section
<A HREF="sect01.html">1</A> / <A HREF="sect02.html">2</A> /
<A HREF="sect03.html">3</A> / <A HREF="sect04.html">4</A> /
<A HREF="sect05.html">5</A> / <A HREF="sect06.html">6</A> /
<A HREF="sect07.html">7</A> / <A HREF="sect08.html">8</A> /
<A HREF="sect09.html">9</A> / <A HREF="sect10.html">10</A> /
<A HREF="sect11.html">11</A> / <A HREF="sect12.html">12</A> /
<A HREF="sect13.html">13</A> / <A HREF="sect14.html">14</A> /
<A HREF="sect15.html">15</A> / <A HREF="sect16.html">16</A>
<P>Appendix
<A HREF="appa.html">A</A> / <A HREF="appb.html">B</A> /
<A HREF="appc.html">C</A> / <A HREF="appd.html">D</A> /
<A HREF="appe.html">E</A> / <A HREF="appf.html">F</A>
</P>
<HR>

</BODY></HTML>
